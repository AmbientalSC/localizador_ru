<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="stylesheet" href="css/leaflet.css">
    <link rel="stylesheet" href="css/L.Control.Layers.Tree.css">
    <link rel="stylesheet" href="css/qgis2web.css">
    <link rel="stylesheet" href="css/fontawesome-all.min.css">
    <link rel="stylesheet" href="css/filter.css">
    <link rel="stylesheet" href="css/tabela.css">
    <link rel="stylesheet" href="css/nouislider.min.css">
    <link rel="stylesheet" href="css/leaflet-control-geocoder.Geocoder.css">
    <script src="data/styles.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.11.5/css/jquery.dataTables.css">
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.js">
    </script>
    <title>Consulta de setores</title>
    <link rel="shortcut icon" type="image/jpg" href="icon.ico" />
</head>

<body>
    <div id="streetViewContainer"></div>
    <div id="map"></div>
    
    <button id="toggle-button">Minimizar setores</button>
    <div id="table-container">
        <table id="sectors-table" class="display">
            <thead>
                <tr>
                    <th>Setor</th>
                    <th>Turno</th>
                    <th>Frequência</th>
                    <th>Horário</th>
                    <th>Operação</th>
                    <th>Filial</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <script src="js/qgis2web_expressions.js"></script>
    <script src="js/leaflet.js"></script>
    <script src="js/leaflet.rotatedMarker.js"></script>
    <script src="js/leaflet.pattern.js"></script>
    <script src="js/leaflet-hash.js"></script>
    <script src="js/Autolinker.min.js"></script>
    <script src="js/rbush.min.js"></script>
    <script src="js/labelgun.min.js"></script>
    <script src="js/labels.js"></script>
    <script src="js/leaflet-control-geocoder.Geocoder.js"></script>
    <script src="js/tailDT.js"></script>
    <script src="js/nouislider.min.js"></script>
    <script src="js/wNumb.js"></script>
    <script src="js/geoJsonLoader.js"></script>
    <!-- Google Analytics removido temporariamente para evitar erro de certificado -->
    <script>


</script>

    <script type="text/javascript">
        // Variáveis globais para o mapa e camadas
        var map, bounds_group, layer_Mesclado_1;
        var Filters = {
            "OPERACAO": "str"
        };

        // Função para inicializar a aplicação quando os dados estiverem prontos
        function initializeApp() {
            if (!window.json_Mesclado_1) {
                return;
            }
            
            if (!window.json_Mesclado_1.features) {
                return;
            }
            
            var data = json_Mesclado_1.features;
            var activeSector = null;

                // Inicializar DataTable apenas uma vez
                if (!$.fn.DataTable.isDataTable('#sectors-table')) {
                    data.forEach(function (feature) {
                        var name = feature.properties['SETOR'] || '';
                        var turno = feature.properties['TURNO'] || '';
                        var frequencia = feature.properties['FREQUENCIA'] || '';
                        var horario = feature.properties['HORARIO'] || '';
                        var operacao = feature.properties['OPERACAO'] || '';
                        var filial = feature.properties['FILIAL'] || '';

                        $('#sectors-table tbody').append(
                            '<tr data-setor="' + name + '" data-filial="' + filial + '">' +
                            '<td>' + name + '</td>' +
                            '<td>' + turno + '</td>' +
                            '<td>' + frequencia + '</td>' +
                            '<td>' + horario + '</td>' +
                            '<td>' + operacao + '</td>' +
                            '<td>' + filial + '</td>' +
                            '</tr>'
                        );
                    });                $('#sectors-table thead th').each(function () {
                    var title = $(this).text();
                    $(this).html('<input type="text" style="width: 101px;" placeholder="' + title + '" />');
                });

                var table = $('#sectors-table').DataTable({
                    scrollY: '300px',
                    scrollX: true,
                    scrollCollapse: true,
                    paging: false,
                    fixedColumns: true,
                    dom: 't',
                responsive: true
            });

            table.columns().every(function () {
                var that = this;

                $('input', this.header()).on('keyup change', function () {
                    if (that.search() !== this.value) {
                        that.search(this.value).draw();
                    }
                });
            });

            // Função para minimizar/expandir tabela
            $('#toggle-button').click(function () {
                if ($('#table-container').is(':visible')) {
                    $('#table-container').hide();
                    $('#toggle-button').text('Expandir setores');
                } else {
                    $('#table-container').show();
                    $('#toggle-button').text('Minimizar setores');
                }
            });


            $('#sectors-table tbody').on('click', 'tr', function () {
                var setor = $(this).attr('data-setor'); 
                var filial = $(this).attr('data-filial'); 
                if (activeSector && activeSector.setor === setor && activeSector.filial === filial) {
                    activeSector = null;
                    map.eachLayer(function (layer) {
                        if (layer.feature) {
                            // Restaura o estilo original usando sua função de estilo
                            layer.setStyle(style_Mesclado_1_0(layer.feature));
                        }
                    });
                    return; // finaliza a execução
                }
            
                // Caso contrário, atualiza o setor ativo
                activeSector = { setor: setor, filial: filial };
                map.eachLayer(function (layer) {
                    if (layer.feature && layer.feature.properties['SETOR'] === setor && layer
                        .feature.properties['FILIAL'] === filial) {
                        var bounds = layer.getBounds(); // Obtém os limites do setor
                        map.fitBounds(bounds); // Dá zoom no setor

                        // Monta o conteúdo do popup baseado nas propriedades do setor
                        var popupContent = '<table>' +
                            '<tr><th>Setor</th><td>' + (layer.feature.properties['SETOR'] || '') +
                            '</td></tr>' +
                            '<tr><th>Turno</th><td>' + (layer.feature.properties['TURNO'] || '') +
                            '</td></tr>' +
                            '<tr><th>Frequência</th><td>' + (layer.feature.properties[
                                'FREQUENCIA'] || '') + '</td></tr>' +
                            '<tr><th>Horário</th><td>' + (layer.feature.properties['HORARIO'] || '') +
                            '</td></tr>' +
                            '<tr><th>Operação</th><td>' + (layer.feature.properties['OPERACAO'] || '') +
                            '</td></tr>' +
                            '<tr><th>Filial</th><td>' + (layer.feature.properties['FILIAL'] || '') +
                            '</td></tr>' +
                            '</table>';

                        layer.bindPopup(popupContent).openPopup(); // Abre o popup no setor
                    }
                });
            });
            } // Fechamento do if (!$.fn.DataTable.isDataTable)

            // Criar ou atualizar a camada do mapa
            createMapLayer();
            
            // Inicializar filtros após criar a camada
            initializeFilters();
            
            // Redimensionar mapa após tudo estar configurado
            setTimeout(function() {
                if (map) {
                    map.invalidateSize();
                }
            }, 500);
        }

        // Função para criar/atualizar a camada do mapa
        function createMapLayer() {
            // Se a camada já existe, remover do mapa
            if (layer_Mesclado_1) {
                map.removeLayer(layer_Mesclado_1);
                bounds_group.removeLayer(layer_Mesclado_1);
            }

            // Criar nova camada com os dados atualizados
            layer_Mesclado_1 = new L.geoJson(json_Mesclado_1, {
                attribution: '',
                interactive: true,
                dataVar: 'json_Mesclado_1',
                layerName: 'layer_Mesclado_1',
                pane: 'pane_Mesclado_1',
                onEachFeature: pop_Mesclado_1,
                style: style_Mesclado_1_0,
            });

            // Adicionar camada ao mapa
            bounds_group.addLayer(layer_Mesclado_1);
            map.addLayer(layer_Mesclado_1);

            // Ajustar zoom para mostrar todas as features
            if (json_Mesclado_1.features.length > 0) {
                map.fitBounds(bounds_group.getBounds());
            }
        }

        // Função para inicializar os filtros
        function initializeFilters() {
            // Criar o menu se não existir
            var menuDiv = document.getElementById("menu");
            if (!menuDiv) {
                menuDiv = document.createElement('div');
                menuDiv.id = "menu";
                document.body.appendChild(menuDiv);
            }
            
            // Verificar se o filtro já existe para evitar duplicação
            if (document.getElementById("div_OPERACAO")) {
                return;
            }
            
            // Criar filtro de OPERACAO
            var div_OPERACAO = document.createElement('div');
            div_OPERACAO.id = "div_OPERACAO";
            div_OPERACAO.className = "filterselect";
            
            // Adicionar título do filtro
            var titulo_OPERACAO = document.createElement('div');
            titulo_OPERACAO.className = 'filter-title';
            titulo_OPERACAO.innerHTML = 'Filtrar por Operação';
            div_OPERACAO.appendChild(titulo_OPERACAO);
            
            menuDiv.appendChild(div_OPERACAO);
            
            var sel_OPERACAO = document.createElement('select');
            sel_OPERACAO.multiple = true;
            sel_OPERACAO.size = 3;
            sel_OPERACAO.id = "sel_OPERACAO";
            
            var OPERACAO_options_str = "<option value='DOMICILIAR' unselected>Domiciliar</option>";
            sel_OPERACAO.onchange = function () {
                filterFunc()
            };
            OPERACAO_options_str += '<option value="SELETIVA">Seletiva</option>';
            OPERACAO_options_str += '<option value="VOLUMOSOS">Volumosos BC</option>';
            sel_OPERACAO.innerHTML = OPERACAO_options_str;
            div_OPERACAO.appendChild(sel_OPERACAO);
            
            var lab_OPERACAO = document.createElement('div');
            div_OPERACAO.appendChild(lab_OPERACAO);
            
            var reset_OPERACAO = document.createElement('div');
            reset_OPERACAO.innerHTML = 'Limpar Filtro';
            reset_OPERACAO.className = 'filterlabel';
            reset_OPERACAO.onclick = function () {
                var options = document.getElementById("sel_OPERACAO").options;
                for (var i = 0; i < options.length; i++) {
                    options[i].selected = false;
                }
                filterFunc();
            };
            div_OPERACAO.appendChild(reset_OPERACAO);
        }

        // Função para inicializar o mapa base
        function initializeMap() {
            // Criar o mapa apenas uma vez
            if (!map) {
                map = L.map('map', {
                    zoomControl: false,
                    maxZoom: 20,
                    minZoom: 1
                }).fitBounds([
                    [-29.385666846354212, -53.97343868194244],
                    [-24.750071928660105, -47.854453390586215]
                ]);

                // Configurar hash e atribuição
                var hash = new L.Hash(map);
                map.attributionControl.setPrefix(
                    '<a href="https://github.com/AmbientalSC" target="_blank">Alysson Krombauer</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Rev 14/03/2025</a> &middot;'
                );

                // Criar bounds group
                bounds_group = new L.featureGroup([]);

                // Função setBounds (mantida para compatibilidade)
                function setBounds() {}

                // Criar pane para OpenStreetMap
                map.createPane('pane_OpenStreetMap_0');
                map.getPane('pane_OpenStreetMap_0').style.zIndex = 400;
                
                // Adicionar tile layer
                var layer_OpenStreetMap_0 = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    pane: 'pane_OpenStreetMap_0',
                    opacity: 1.0,
                    attribution: '',
                    minZoom: 1,
                    maxZoom: 20,
                    interactive: false
                });
                map.addLayer(layer_OpenStreetMap_0);

                // Criar pane para os dados GeoJSON
                map.createPane('pane_Mesclado_1');
                map.getPane('pane_Mesclado_1').style.zIndex = 401;
                map.getPane('pane_Mesclado_1').style['mix-blend-mode'] = 'normal';

                // Inicializar controles adicionais
                initializeMapControls();
                // Observador que esconde/removê o container padrão do Leaflet se vazio ou sem controles úteis
                (function observeLeafletControlContainer() {
                    try {
                        function isMeaningful(node) {
                            if (!node) return false;
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                if (node.classList.contains('leaflet-control') && node.querySelector('.leaflet-control-geocoder, .leaflet-control-zoom, input, button, select')) return true;
                                if (node.childElementCount > 0) return Array.prototype.slice.call(node.children).some(isMeaningful);
                                if (node.textContent && node.textContent.trim().length > 0) return true;
                            }
                            return false;
                        }

                        function cleanup() {
                            var ctl = document.querySelector('.leaflet-control-container');
                            if (!ctl) return;
                            var has = Array.prototype.slice.call(ctl.children).some(isMeaningful);
                            if (!has) {
                                // hide first to avoid layout jump then remove
                                ctl.style.display = 'none';
                            } else {
                                ctl.style.display = '';
                            }
                        }

                        // Initial cleanup
                        cleanup();

                        // Observe additions/removals
                        var root = document.body;
                        var mo = new MutationObserver(function(mutations) {
                            var relevant = mutations.some(function(m) {
                                return Array.prototype.slice.call(m.addedNodes).concat(Array.prototype.slice.call(m.removedNodes)).some(function(n) {
                                    return n && (n.classList && n.classList.contains && n.classList.contains('leaflet-control-container')) || (n && n.querySelector && n.querySelector('.leaflet-control-container'));
                                });
                            });
                            if (relevant) cleanup();
                        });
                        mo.observe(root, { childList: true, subtree: true });
                        // também observe mudanças internas no container
                        var ctl = document.querySelector('.leaflet-control-container');
                        if (ctl) mo.observe(ctl, { childList: true, subtree: true });
                    } catch (e) {
                        console.warn('Observer leaflet-control-container falhou:', e);
                    }
                })();
            }
        }

        // Função para inicializar controles do mapa
        function initializeMapControls() {
            // Autolinker para formatação de popup
            window.autolinker = new Autolinker({
                truncate: {
                    length: 30,
                    location: 'smart'
                }
            });

            // Inicializar geocoder após mapa estar pronto
            setTimeout(function() {
                initializeGeocoder();
            }, 500);

            // --- Remoção forçada de controles do plugin (leaflet-control-geocoder) ---
            // Alguns plugins adicionam um controle com as classes
            // 'leaflet-control-geocoder leaflet-bar leaflet-control'. Como usamos um
            // geocoder customizado, removemos esses nodes do DOM para evitar sobreposição.
            function removePluginGeocoderControls() {
                try {
                    var els = document.querySelectorAll('.leaflet-control-geocoder.leaflet-bar.leaflet-control');
                    els.forEach(function(el) {
                        if (el && el.parentNode) el.parentNode.removeChild(el);
                    });
                    // Se o container do Leaflet ficar sem controles úteis, esconder
                    var ctl = document.querySelector('.leaflet-control-container');
                    if (ctl) {
                        var hasMeaningful = Array.prototype.slice.call(ctl.children).some(function(n) {
                            return n && n.querySelector && (
                                n.querySelector('.leaflet-control-geocoder, .leaflet-control-zoom, input, button, select')
                            );
                        });
                        if (!hasMeaningful) ctl.style.display = 'none';
                    }
                } catch (e) {
                    console.warn('Falha ao remover controles do geocoder plugin:', e);
                }
            }

            // Agendar limpeza após inicialização e observar DOM para remoções futuras
            setTimeout(removePluginGeocoderControls, 1200);
            try {
                var geocoderCleanupObserver = new MutationObserver(function() {
                    removePluginGeocoderControls();
                });
                geocoderCleanupObserver.observe(document.body, { childList: true, subtree: true });
            } catch (e) {
                // Falar no console, mas não quebrar a aplicação
                console.warn('MutationObserver para limpeza de geocoder não disponível', e);
            }
        }

        // Função para inicializar o geocoder
        function initializeGeocoder() {
            try {
                // Remover container existente se houver
                var existingContainer = document.getElementById('geocoder-container');
                if (existingContainer) {
                    existingContainer.remove();
                }
                
                // Criar container customizado para o geocoder
                var geocoderContainer = document.createElement('div');
                geocoderContainer.id = 'geocoder-container';
                
                // Garantir que o estilo inline funcione
                geocoderContainer.style.cssText = `
                    position: fixed !important;
                    top: 255px !important;
                    left: 20px !important;
                    width: 282px !important;
                    background-color: rgba(255, 255, 255, 0.95) !important;
                    padding: 15px !important;
                    border-radius: 12px !important;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15) !important;
                    z-index: 999 !important;
                    border: 1px solid rgba(0, 0, 0, 0.1) !important;
                    backdrop-filter: blur(10px) !important;
                    box-sizing: border-box !important;
                    display: block !important;
                    visibility: visible !important;
                `;
                
                // Adicionar título
                var geocoderTitle = document.createElement('div');
                geocoderTitle.className = 'geocoder-title';
                geocoderTitle.innerHTML = 'Buscar Endereço';
                geocoderContainer.appendChild(geocoderTitle);
                
                // Criar input customizado
                var searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.placeholder = 'Digite um endereço para buscar...';
                searchInput.className = 'custom-geocoder-input';
                searchInput.style.cssText = `
                    width: calc(100% - 45px);
                    padding: 8px 12px;
                    border: 2px solid #e9ecef;
                    border-radius: 6px;
                    font-size: 13px;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    background: #ffffff;
                    color: #495057;
                    box-sizing: border-box;
                    outline: none;
                    transition: all 0.3s ease;
                `;
                
                // Adicionar ao body primeiro
                document.body.appendChild(geocoderContainer);
                
                // Depois adicionar os elementos
                geocoderContainer.appendChild(searchInput);
                
                var geocodeMarker = null;

                // Helper para mostrar resultado no mapa (Street View + marker)
                function handleGeocodeResult(lat, lng, address) {
                    var latlng = [lat, lng];
                    var streetViewDiv = document.getElementById('streetViewContainer');
                    streetViewDiv.innerHTML = '';
                    var streetViewFrame = document.createElement('iframe');
                    streetViewFrame.setAttribute('width', '100%');
                    streetViewFrame.setAttribute('height', '200px');
                    streetViewFrame.setAttribute('frameborder', '0');
                    streetViewFrame.setAttribute('style', 'border:0;');
                    streetViewFrame.setAttribute('src',
                        `https://www.google.com/maps/embed/v1/streetview?key=${window.GOOGLE_API_KEY || 'AIzaSyCiKpZmnL9TQXOJd9Qbzw2agE9kxnTGZ38'}&location=${lat},${lng}&heading=210&pitch=10&fov=35`
                    );
                    streetViewDiv.appendChild(streetViewFrame);

                    if (geocodeMarker) {
                        map.removeLayer(geocodeMarker);
                    }
                    geocodeMarker = L.marker(latlng).addTo(map)
                        .bindPopup(`<b>${address || ''}</b> <br><a href='https://www.google.com/maps?q=&layer=c&cbll=${lat},${lng}&cbp=11,0,0,0,0' target='_blank'>Abrir Street View</a>`)
                        .openPopup();
                    map.setView(latlng, 18);
                }

                // Função de busca customizada usando Nominatim (fallback)
                function performSearchWithOSM(query) {
                    if (!query.trim()) return;
                    var nominatimUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;
                    fetch(nominatimUrl)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.length > 0) {
                                var result = data[0];
                                handleGeocodeResult(parseFloat(result.lat), parseFloat(result.lon), result.display_name);
                            } else {
                                alert('Endereço não encontrado');
                            }
                        })
                        .catch(error => {
                            alert('Erro na busca do endereço');
                        });
                }

                // Se o provider Google do plugin estiver disponível, cria controle Google
                if (typeof L !== 'undefined' && L.Control && L.Control.Geocoder && typeof L.Control.Geocoder.google === 'function') {
                    try {
                        var googleProvider = L.Control.Geocoder.google(window.GOOGLE_API_KEY || 'AIzaSyCiKpZmnL9TQXOJd9Qbzw2agE9kxnTGZ38', {});
                        var googleGeocoderControl = new L.Control.Geocoder({
                            geocoder: googleProvider,
                            collapsed: true,
                            position: 'topleft',
                            text: 'Buscar',
                            title: 'Buscar com Google'
                        }).addTo(map);

                        // Quando o controle resolver um resultado, usar o handler para mostrar no mapa
                        googleGeocoderControl.on('markgeocode', function(e) {
                            var center = e.geocode.center;
                            handleGeocodeResult(center.lat, center.lng, e.geocode.name || '');
                        });

                        // Além disso, conectar o input custom ao controle, se possível
                        var customInput = document.querySelector('.custom-geocoder-input');
                        if (customInput) {
                            // Função robusta para chamar o provider Google e tratar formatos
                            function googleGeocodeAndHandle(query) {
                                if (!query || !query.trim()) return;
                                try {
                                    googleProvider.geocode(query, function(results) {
                                        console.log('googleProvider.geocode results:', results);
                                        var lat, lng, address;
                                        // Caso: plugin já retorna array de resultados com center
                                        if (Array.isArray(results) && results.length > 0) {
                                            var r = results[0];
                                            if (r.center) {
                                                // center pode ser L.LatLng ou objeto
                                                lat = (typeof r.center.lat === 'function') ? r.center.lat() : r.center.lat;
                                                lng = (typeof r.center.lng === 'function') ? r.center.lng() : r.center.lng;
                                            } else if (r.geometry && r.geometry.location) {
                                                lat = r.geometry.location.lat;
                                                lng = r.geometry.location.lng;
                                            }
                                            address = r.name || r.formatted_address || '';
                                        } else if (results && results.results && results.results.length > 0) {
                                            // Caso: resposta bruta da API Google (objeto com results[])
                                            var g = results.results[0];
                                            if (g.geometry && g.geometry.location) {
                                                lat = g.geometry.location.lat;
                                                lng = g.geometry.location.lng;
                                            }
                                            address = g.formatted_address || g.address_components || '';
                                        } else if (Array.isArray(results) && results.length === 0) {
                                            // Provider retornou array vazio — tentar fallback direto ao endpoint REST
                                            try {
                                                var restUrl = 'https://maps.googleapis.com/maps/api/geocode/json?address=' + encodeURIComponent(query) + '&key=' + (window.GOOGLE_API_KEY || '') + '&components=country:BR';
                                                console.log('Tentando fallback Google REST:', restUrl);
                                                fetch(restUrl)
                                                    .then(function(resp) { return resp.json(); })
                                                    .then(function(gres) {
                                                        console.log('Google REST response:', gres);
                                                        if (gres && gres.status === 'OK' && gres.results && gres.results.length > 0) {
                                                            var gg = gres.results[0];
                                                            if (gg.geometry && gg.geometry.location) {
                                                                handleGeocodeResult(gg.geometry.location.lat, gg.geometry.location.lng, gg.formatted_address || '');
                                                            } else {
                                                                console.warn('Google REST sem geometry:', gg);
                                                                alert('Endereço não encontrado (Google)');
                                                            }
                                                        } else {
                                                            console.warn('Google REST não retornou resultados:', gres && gres.status);
                                                            alert('Endereço não encontrado (Google)');
                                                        }
                                                    })
                                                    .catch(function(err) {
                                                        console.error('Erro no fallback Google REST:', err);
                                                        alert('Erro no Geocoding Google');
                                                    });
                                            } catch (err) {
                                                console.error('Erro ao tentar fallback REST:', err);
                                                alert('Erro no Geocoding Google');
                                            }
                                            return; // já lidamos com a resposta no fallback
                                        }

                                        if (typeof lat !== 'undefined' && typeof lng !== 'undefined') {
                                            handleGeocodeResult(lat, lng, address);
                                        } else {
                                            console.warn('Google geocode retornou sem coordenadas:', results);
                                            alert('Endereço não encontrado (Google)');
                                        }
                                    });
                                } catch (err) {
                                    console.error('Erro ao chamar googleProvider.geocode', err);
                                    alert('Erro no geocoder Google');
                                }
                            }

                            customInput.addEventListener('keydown', function(e) {
                                if (e.key === 'Enter') {
                                    e.preventDefault();
                                    googleGeocodeAndHandle(this.value);
                                }
                            });
                        }

                        // Também add o botão existente para delegar ao provider
                        var searchButton = geocoderContainer.querySelector('button');
                        if (searchButton && customInput) {
                            searchButton.onclick = function() { googleGeocodeAndHandle(customInput.value); };
                        }

                        return; // termina initializeGeocoder com Google provider ativo
                    } catch (err) {
                        console.warn('Erro ao inicializar Google Geocoder provider, fallback para OSM', err);
                    }
                }

                // Se não entrou no bloco Google provider, mantém o comportamento custom (OSM)
                // conectar input do UI ao performSearchWithOSM
                var customInput = document.querySelector('.custom-geocoder-input');
                if (customInput) {
                    customInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            performSearchWithOSM(this.value);
                        }
                    });
                }
                var searchButton = geocoderContainer.querySelector('button');
                if (searchButton && customInput) {
                    searchButton.onclick = function() { performSearchWithOSM(customInput.value); };
                }
                
                // Eventos do input
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        performSearch(this.value);
                    }
                });
                
                // Adicionar botão de busca
                var searchButton = document.createElement('button');
                searchButton.innerHTML = '🔍';
                searchButton.title = 'Buscar endereço';
                searchButton.style.cssText = `
                    position: absolute;
                    right: 18px;
                    top: 52px;
                    width: 32px;
                    height: 32px;
                    border: 2px solid #007bff;
                    background: linear-gradient(135deg, #007bff, #0056b3);
                    color: white;
                    cursor: pointer;
                    font-size: 14px;
                    border-radius: 6px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1001;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
                `;
                
                // Adicionar efeitos hover
                searchButton.onmouseover = function() {
                    this.style.background = 'linear-gradient(135deg, #0056b3, #004085)';
                    this.style.transform = 'scale(1.05)';
                    this.style.boxShadow = '0 4px 8px rgba(0, 123, 255, 0.3)';
                };
                
                searchButton.onmouseout = function() {
                    this.style.background = 'linear-gradient(135deg, #007bff, #0056b3)';
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = '0 2px 4px rgba(0, 123, 255, 0.2)';
                };
                
                searchButton.onclick = function() {
                    performSearch(searchInput.value);
                };
                
                // Tornar o container relativo para o botão
                geocoderContainer.style.position = 'fixed';
                geocoderContainer.appendChild(searchButton);
                
            } catch (error) {
                // Fallback: criar versão mais simples
                createFallbackGeocoder();
            }
        }
        
        // Função fallback para criar geocoder simples
        function createFallbackGeocoder() {
            var geocoderContainer = document.createElement('div');
            geocoderContainer.id = 'geocoder-container';
            geocoderContainer.style.cssText = `
                position: fixed !important;
                top: 255px !important;
                left: 20px !important;
                width: 282px !important;
                background-color: rgba(255, 255, 255, 0.95) !important;
                padding: 15px !important;
                border-radius: 12px !important;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15) !important;
                z-index: 999 !important;
                border: 1px solid rgba(0, 0, 0, 0.1) !important;
                display: block !important;
            `;
            
            var title = document.createElement('div');
            title.innerHTML = 'Buscar Endereço';
            title.style.cssText = 'font-weight: 600; margin-bottom: 10px; font-size: 14px;';
            geocoderContainer.appendChild(title);
            
            var fallbackInput = document.createElement('input');
            fallbackInput.type = 'text';
            fallbackInput.placeholder = 'Digite um endereço para buscar...';
            fallbackInput.style.cssText = `
                width: 100% !important;
                padding: 8px 12px !important;
                border: 2px solid #e9ecef !important;
                border-radius: 6px !important;
                font-size: 13px !important;
                box-sizing: border-box !important;
            `;
            
            geocoderContainer.appendChild(fallbackInput);
            document.body.appendChild(geocoderContainer);
        }

        // Aguardar o carregamento dos dados GeoJSON
        $(document).ready(function () {
            // Inicializar o mapa primeiro
            initializeMap();
            
            // Verificar se os dados já estão carregados
            function checkDataAndInitialize() {
                if (window.json_Mesclado_1 && window.json_Mesclado_1.features) {
                    initializeApp();
                } else {
                    setTimeout(checkDataAndInitialize, 500);
                }
            }
            
            // Iniciar verificação
            checkDataAndInitialize();
            
            // Backup: também escutar o evento
            window.addEventListener('geoJsonLoaded', function() {
                initializeApp();
            });
        });
    </script>
    <script>
        // Funções de highlight para o mapa
        var highlightLayer;

        function highlightFeature(e) {
            highlightLayer = e.target;

            if (e.target.feature.geometry.type === 'LineString' || e.target.feature.geometry.type ===
                'MultiLineString') {
                highlightLayer.setStyle({
                    color: '#ffff00',
                });
            } else {
                highlightLayer.setStyle({
                    fillColor: '#ffff00',
                    fillOpacity: 1
                });
            }
        }

        var autolinker = new Autolinker({
            truncate: {
                length: 30,
                location: 'smart'
            }
        });

        function removeEmptyRowsFromPopupContent(content, feature) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            var rows = tempDiv.querySelectorAll('tr');
            for (var i = 0; i < rows.length; i++) {
                var td = rows[i].querySelector('td.visible-with-data');
                var key = td ? td.id : '';
                if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                    rows[i].parentNode.removeChild(rows[i]);
                }
            }
            return tempDiv.innerHTML;
        }
        // add class to format popup if it contains media
        function addClassToPopupIfMedia(content, popup) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            if (tempDiv.querySelector('td img')) {
                popup._contentNode.classList.add('media');
                // Delay to force the redraw
                setTimeout(function () {
                    popup.update();
                }, 10);
            } else {
                popup._contentNode.classList.remove('media');
            }
        }

        function pop_Mesclado_1(feature, layer) {
            layer.on({
                mouseout: function (e) {
                    for (var i in e.target._eventParents) {
                        if (typeof e.target._eventParents[i].resetStyle === 'function') {
                            e.target._eventParents[i].resetStyle(e.target);
                        }
                    }
                },
                mouseover: highlightFeature,
            });
            
            // Função auxiliar para formatar propriedades com segurança
            function formatProperty(value) {
                if (value !== null && value !== undefined) {
                    return autolinker.link(value.toString());
                }
                return '';
            }
            
            var popupContent = '<table>\
                    <tr>\
                        <th scope="row">SETOR</th>\
                        <td>' + formatProperty(feature.properties['SETOR']) + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">FILIAL</th>\
                        <td>' + formatProperty(feature.properties['FILIAL']) + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">FREQUENCIA</th>\
                        <td>' + formatProperty(feature.properties['FREQUENCIA']) + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">HORARIO</th>\
                        <td>' + formatProperty(feature.properties['HORARIO']) + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">OPERACAO</th>\
                        <td>' + formatProperty(feature.properties['OPERACAO']) + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">TURNO</th>\
                        <td>' + formatProperty(feature.properties['TURNO']) + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
            layer.on('popupopen', function (e) {
                addClassToPopupIfMedia(content, e.popup);
            });
            layer.bindPopup(content, {
                maxHeight: 400
            });
        }

        // --- MELHORIAS DE USABILIDADE E PERFORMANCE ---
        // (Geocoder movido para initializeGeocoder)

        // 2. Feedback visual ao buscar endereço
        var geocoderInput = document.querySelector('.leaflet-control-geocoder-form input');
        if (geocoderInput) {
            geocoderInput.addEventListener('keydown', function() {
                var streetViewDiv = document.getElementById('streetViewContainer');
                streetViewDiv.innerHTML = '<span style="color:#888">Buscando endereço...</span>';
            });
        }

        // 3. Acessibilidade no botão de tabela
        var toggleBtn = document.getElementById('toggle-button');
        if (toggleBtn) {
            toggleBtn.setAttribute('aria-pressed', 'false');
            toggleBtn.setAttribute('aria-label', 'Minimizar ou expandir setores');
            toggleBtn.addEventListener('click', function () {
                var expanded = document.getElementById('table-container').style.display !== 'none';
                this.setAttribute('aria-pressed', expanded ? 'false' : 'true');
            });
        }

        // 4. Responsividade básica para o mapa e tabela
        var style = document.createElement('style');
        style.innerHTML = `
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        
        #map {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: #ffffff;
        }
        
        #streetViewContainer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        #table-container {
            position: fixed;
            top: 65px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            z-index: 1000;
            overflow-y: auto;
            max-height: 400px;
            max-width: 800px;
            width: auto;
        }
        
        #toggle-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1100;
        }
        
        table.display {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Calibri', sans-serif;
            font-size: 11px;
        }
        
        table.display th,
        table.display td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        table.display th {
            background-color: #f2f2f2;
        }
        
        @media (min-width: 1200px) {
            #table-container {
                max-width: 900px;
            }
        }
        
        @media (max-width: 800px) {
            #table-container {
                top: 60px;
                right: 10px;
                left: 10px;
                max-height: 200px;
                max-width: none;
            }
            #toggle-button {
                top: 10px;
                right: 10px;
                padding: 8px 15px;
            }
        }
        `;
        document.head.appendChild(style);

        function filterFunc() {
            map.eachLayer(function (lyr) {
                if ("options" in lyr && "dataVar" in lyr["options"]) {
                    features = this[lyr["options"]["dataVar"]].features.slice(0);
                    try {
                        for (key in Filters) {
                            keyS = key.replace(/[^a-zA-Z0-9_]/g, "")
                            if (Filters[key] == "str" || Filters[key] == "bool") {
                                var selection = [];
                                var options = document.getElementById("sel_" + keyS).options
                                for (var i = 0; i < options.length; i++) {
                                    if (options[i].selected) selection.push(options[i].value);
                                }
                                try {
                                    if (key in features[0].properties) {
                                        for (i = features.length - 1; i >= 0; --i) {
                                            if (selection.indexOf(
                                                    features[i].properties[key]) < 0 &&
                                                selection.length > 0) {
                                                features.splice(i, 1);
                                            }
                                        }
                                    }
                                } catch (err) {}
                            }
                            if (Filters[key] == "int") {
                                sliderVals = document.getElementById(
                                    "div_" + keyS).noUiSlider.get();
                                try {
                                    if (key in features[0].properties) {
                                        for (i = features.length - 1; i >= 0; --i) {
                                            if (parseInt(features[i].properties[key]) <
                                                sliderVals[0] ||
                                                parseInt(features[i].properties[key]) >
                                                sliderVals[1]) {
                                                features.splice(i, 1);
                                            }
                                        }
                                    }
                                } catch (err) {}
                            }
                            if (Filters[key] == "real") {
                                sliderVals = document.getElementById(
                                    "div_" + keyS).noUiSlider.get();
                                try {
                                    if (key in features[0].properties) {
                                        for (i = features.length - 1; i >= 0; --i) {
                                            if (features[i].properties[key] <
                                                sliderVals[0] ||
                                                features[i].properties[key] >
                                                sliderVals[1]) {
                                                features.splice(i, 1);
                                            }
                                        }
                                    }
                                } catch (err) {}
                            }
                            if (Filters[key] == "date" ||
                                Filters[key] == "datetime" ||
                                Filters[key] == "time") {
                                try {
                                    if (key in features[0].properties) {
                                        HTMLkey = key.replace(/[&\/\\#,+()$~%.'":*?<>{} ]/g, '');
                                        startdate = document.getElementById("dat_" +
                                            HTMLkey + "_date1").value.replace(" ", "T");
                                        enddate = document.getElementById("dat_" +
                                            HTMLkey + "_date2").value.replace(" ", "T");
                                        for (i = features.length - 1; i >= 0; --i) {
                                            if (features[i].properties[key] < startdate ||
                                                features[i].properties[key] > enddate) {
                                                features.splice(i, 1);
                                            }
                                        }
                                    }
                                } catch (err) {}
                            }
                        }
                    } catch (err) {}
                    this[lyr["options"]["layerName"]].clearLayers();
                    this[lyr["options"]["layerName"]].addData(features);
                }
            })
        }
    </script>
</body>
</html>